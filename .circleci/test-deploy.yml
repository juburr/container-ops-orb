version: 2.1
orbs:
  # Your orb will be automatically injected here during the pipeline.
  # Reference your orb's jobs and commands below as they will exist when built.
  orb-tools: circleci/orb-tools@12.3
  # The orb definition is intentionally not included here. It will be injected into the pipeline.
  container-ops-orb: {}
  # Import tagger orb directly for integration testing
  tagger: juburr/container-tagger-orb@0.7.4
  # Import grype orb directly for scan testing
  grype: juburr/grype-orb@0.3.12

# Use this tag to ensure test jobs always run,
# even though the downstream publish job will only run on release tags.
filters: &filters
  tags:
    only: /.*/

# Filter for release tags.
release-filters: &release-filters
  branches:
    ignore: /.*/
  tags:
    only: /^v[0-9]+\.[0-9]+\.[0-9]+$/

jobs:
  # Test individual docker commands
  command-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      # Create a simple test Dockerfile
      - run:
          name: Create test Dockerfile
          command: |
            cat > Dockerfile \<<'EOF'
            # Test Dockerfile for orb validation
            ARG OCI_CREATED
            ARG OCI_REVISION
            ARG OCI_VERSION
            ARG OCI_SOURCE

            FROM alpine:3.20

            LABEL org.opencontainers.image.title="Test Image"
            LABEL org.opencontainers.image.description="Test image for container-ops-orb validation"
            LABEL org.opencontainers.image.created="${OCI_CREATED}"
            LABEL org.opencontainers.image.revision="${OCI_REVISION}"
            LABEL org.opencontainers.image.version="${OCI_VERSION}"

            RUN echo "Hello from container-ops-orb test image"
            EOF
      # Test docker-build command
      - container-ops-orb/docker_build:
          image: test-image
          tags: "test-tag ${CIRCLE_SHA1}"
          oci_labels: true
      # Test docker-inspect command
      - container-ops-orb/docker_inspect:
          image: test-image
          tag: test-tag
      # Test docker-archive command (without workspace persistence for this test)
      - container-ops-orb/docker_archive:
          image: test-image
          tag: test-tag
          persist_to_workspace: false
      # Verify the archive was created
      - run:
          name: Verify archive exists
          command: |
            if [ -f ~/images/test-image-img.tar ]; then
              echo "Archive created successfully!"
              ls -la ~/images/
            else
              echo "ERROR: Archive not found"
              exit 1
            fi
      # Test docker-load command
      - run:
          name: Remove image to test load
          command: docker rmi test-image:test-tag
      - container-ops-orb/docker_load:
          image: test-image
      # Verify image was loaded
      - run:
          name: Verify image loaded
          command: docker image inspect test-image:test-tag

      # Test docker_tag command - tag image for a mock registry
      - container-ops-orb/docker_tag:
          source_image: "test-image:test-tag"
          target_image: "localhost:5000/test-org/test-image"
          tags: "v1.0.0 latest ${CIRCLE_SHA1}"
      # Verify tags were applied
      - run:
          name: Verify docker_tag created expected tags
          command: |
            echo "Verifying tagged images exist..."
            docker image inspect localhost:5000/test-org/test-image:v1.0.0
            docker image inspect localhost:5000/test-org/test-image:latest
            docker image inspect localhost:5000/test-org/test-image:${CIRCLE_SHA1}
            echo "All expected tags verified!"

      # Verify TAGGED_IMAGE environment variables were set
      - run:
          name: Verify TAGGED_IMAGE env vars
          command: |
            source "${BASH_ENV}"
            echo "TAGGED_IMAGE: ${TAGGED_IMAGE}"
            echo "TAGGED_IMAGE_TAG: ${TAGGED_IMAGE_TAG}"
            echo "TAGGED_IMAGE_FULL: ${TAGGED_IMAGE_FULL}"
            if [ "${TAGGED_IMAGE}" != "localhost:5000/test-org/test-image" ]; then
              echo "ERROR: TAGGED_IMAGE mismatch"
              exit 1
            fi
            if [ "${TAGGED_IMAGE_TAG}" != "v1.0.0" ]; then
              echo "ERROR: TAGGED_IMAGE_TAG mismatch"
              exit 1
            fi
            echo "Environment variables verified!"

  # Test docker_tag and docker_push commands with a local registry
  tag-push-command-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      # Start a local Docker registry for testing
      - run:
          name: Start local Docker registry
          command: |
            docker run -d -p 5000:5000 --name registry registry:2
            # Wait for registry to be ready
            sleep 3
            echo "Local registry started on localhost:5000"

      # Create and build a test image
      - run:
          name: Create and build test image
          command: |
            cat > Dockerfile \<<'EOF'
            FROM alpine:3.20
            LABEL org.opencontainers.image.title="Tag Push Test"
            CMD ["echo", "Tag and push test"]
            EOF
            docker build -t push-test-image:original .

      # Test docker_tag command with multiple tags
      - container-ops-orb/docker_tag:
          source_image: "push-test-image:original"
          target_image: "localhost:5000/myorg/push-test"
          tags: "v2.0.0 v2.0 v2 latest"

      # Test docker_push command - push to local registry
      - container-ops-orb/docker_push:
          image: "localhost:5000/myorg/push-test"
          tags: "v2.0.0 v2.0 v2 latest"

      # Verify images were pushed to registry
      - run:
          name: Verify images in registry
          command: |
            echo "Verifying images were pushed to local registry..."
            # Pull images back from registry to verify push worked
            docker rmi localhost:5000/myorg/push-test:v2.0.0 || true
            docker rmi localhost:5000/myorg/push-test:latest || true
            docker pull localhost:5000/myorg/push-test:v2.0.0
            docker pull localhost:5000/myorg/push-test:latest
            echo "Successfully pulled images from registry!"

      # Verify PUSHED_IMAGE environment variables were set
      - run:
          name: Verify PUSHED_IMAGE env vars
          command: |
            source "${BASH_ENV}"
            echo "PUSHED_IMAGE: ${PUSHED_IMAGE}"
            echo "PUSHED_IMAGE_TAG: ${PUSHED_IMAGE_TAG}"
            echo "PUSHED_IMAGE_FULL: ${PUSHED_IMAGE_FULL}"
            if [ "${PUSHED_IMAGE}" != "localhost:5000/myorg/push-test" ]; then
              echo "ERROR: PUSHED_IMAGE mismatch"
              exit 1
            fi
            echo "Environment variables verified!"

      # Cleanup
      - run:
          name: Stop local registry
          command: docker stop registry && docker rm registry

  # Test publish job with local registry (no external credentials needed)
  publish-job-local-registry-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      # Start local registry
      - run:
          name: Start local Docker registry
          command: |
            docker run -d -p 5000:5000 --name registry registry:2
            sleep 3
            echo "Local registry started"

      # Build and archive test image
      - run:
          name: Create test Dockerfile
          command: |
            cat > Dockerfile \<<'EOF'
            FROM alpine:3.20
            LABEL org.opencontainers.image.title="Publish Job Test"
            CMD ["echo", "Publish job test passed"]
            EOF
      - container-ops-orb/docker_build:
          image: publish-test-app
          tags: "abc123"
      - container-ops-orb/docker_archive:
          image: publish-test-app
          tag: abc123
          persist_to_workspace: false

      # Simulate workspace by keeping the archive
      - run:
          name: Verify archive for publish
          command: ls -la ~/images/

      # Test docker_load (simulating what publish job does)
      - run:
          name: Remove image to test full publish flow
          command: docker rmi publish-test-app:abc123

      # Test the publish flow components
      - container-ops-orb/docker_load:
          image: publish-test-app
          archive_path: ~/images
      - container-ops-orb/docker_tag:
          source_image: "publish-test-app:abc123"
          target_image: "localhost:5000/testorg/publish-test-app"
          tags: "abc123 latest v1.0.0"
      - container-ops-orb/docker_push:
          image: "localhost:5000/testorg/publish-test-app"
          tags: "abc123 latest v1.0.0"

      # Verify published images
      - run:
          name: Verify published images in registry
          command: |
            # Clean local images
            docker rmi localhost:5000/testorg/publish-test-app:abc123 || true
            docker rmi localhost:5000/testorg/publish-test-app:latest || true
            docker rmi localhost:5000/testorg/publish-test-app:v1.0.0 || true

            # Pull from registry
            docker pull localhost:5000/testorg/publish-test-app:abc123
            docker pull localhost:5000/testorg/publish-test-app:latest
            docker pull localhost:5000/testorg/publish-test-app:v1.0.0
            echo "All images published and verified!"

      # Cleanup
      - run:
          name: Cleanup
          command: docker stop registry && docker rm registry

  # Test tagger orb integration for publish job
  tagger-integration-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      # Start local registry
      - run:
          name: Start local Docker registry
          command: |
            docker run -d -p 5000:5000 --name registry registry:2
            sleep 3

      # Build test image
      - run:
          name: Create and build test image
          command: |
            cat > Dockerfile \<<'EOF'
            FROM alpine:3.20
            LABEL org.opencontainers.image.title="Tagger Integration Test"
            CMD ["echo", "Tagger test"]
            EOF
            docker build -t tagger-test:source .

      # Create a tags file (simulating tagger/generate_tags output)
      - run:
          name: Create tags file
          command: |
            cat > tags.txt \<<'EOF'
            1.2.3
            1.2
            1
            latest
            EOF
            echo "Tags file created at $(pwd)/tags.txt:"
            cat tags.txt

      # Test tagger/tag command (using directly imported tagger orb)
      - tagger/tag:
          source_image: "tagger-test:source"
          target_image: "localhost:5000/taggerorg/tagger-test"
          tags_file: tags.txt

      # Verify tags were applied
      - run:
          name: Verify tagger tags applied
          command: |
            docker image inspect localhost:5000/taggerorg/tagger-test:1.2.3
            docker image inspect localhost:5000/taggerorg/tagger-test:1.2
            docker image inspect localhost:5000/taggerorg/tagger-test:1
            docker image inspect localhost:5000/taggerorg/tagger-test:latest
            echo "All tagger tags verified!"

      # Test tagger/push command
      - tagger/push:
          target_image: "localhost:5000/taggerorg/tagger-test"
          tags_file: tags.txt

      # Test tagger/populate_tag command
      - tagger/populate_tag
      - run:
          name: Verify TAG env var populated
          command: |
            source "${BASH_ENV}"
            echo "TAG: ${TAG}"
            if [ -z "${TAG}" ]; then
              echo "ERROR: TAG was not populated"
              exit 1
            fi
            echo "TAG environment variable verified!"

      # Verify images in registry
      - run:
          name: Verify tagger pushed images
          command: |
            docker rmi localhost:5000/taggerorg/tagger-test:1.2.3 || true
            docker pull localhost:5000/taggerorg/tagger-test:1.2.3
            docker pull localhost:5000/taggerorg/tagger-test:latest
            echo "Tagger images verified in registry!"

      # Cleanup
      - run:
          name: Cleanup
          command: docker stop registry && docker rm registry

  # Full build-to-publish integration test using workspace
  build-publish-integration-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      # Start local registry
      - run:
          name: Start local Docker registry
          command: |
            docker run -d -p 5000:5000 --name registry registry:2
            sleep 3

      # Build test image using build command
      - run:
          name: Create test Dockerfile
          command: |
            cat > Dockerfile \<<'EOF'
            ARG OCI_CREATED
            ARG OCI_REVISION
            ARG OCI_VERSION

            FROM alpine:3.20

            LABEL org.opencontainers.image.title="Build-Publish Integration"
            LABEL org.opencontainers.image.created="${OCI_CREATED}"
            LABEL org.opencontainers.image.revision="${OCI_REVISION}"
            LABEL org.opencontainers.image.version="${OCI_VERSION}"

            CMD ["echo", "Build-publish integration test"]
            EOF

      - container-ops-orb/docker_build:
          image: integration-app
          tags: "int123 latest"
          oci_labels: true

      - container-ops-orb/docker_inspect:
          image: integration-app
          tag: int123

      - container-ops-orb/docker_archive:
          image: integration-app
          tag: int123
          persist_to_workspace: false

      # Simulate the publish job flow
      - run:
          name: Remove images to simulate fresh publish environment
          command: |
            docker rmi integration-app:int123 || true
            docker rmi integration-app:latest || true

      - container-ops-orb/docker_load:
          image: integration-app
          archive_path: ~/images

      - container-ops-orb/docker_tag:
          source_image: "integration-app:int123"
          target_image: "localhost:5000/intorg/integration-app"
          tags: "int123 latest v1.0.0 edge"

      - container-ops-orb/docker_push:
          image: "localhost:5000/intorg/integration-app"
          tags: "int123 latest v1.0.0 edge"

      # Comprehensive verification
      - run:
          name: Comprehensive registry verification
          command: |
            echo "=== Cleaning local images ==="
            docker rmi localhost:5000/intorg/integration-app:int123 || true
            docker rmi localhost:5000/intorg/integration-app:latest || true
            docker rmi localhost:5000/intorg/integration-app:v1.0.0 || true
            docker rmi localhost:5000/intorg/integration-app:edge || true

            echo "=== Pulling all tags from registry ==="
            docker pull localhost:5000/intorg/integration-app:int123
            docker pull localhost:5000/intorg/integration-app:latest
            docker pull localhost:5000/intorg/integration-app:v1.0.0
            docker pull localhost:5000/intorg/integration-app:edge

            echo "=== Verifying OCI labels preserved ==="
            docker inspect localhost:5000/intorg/integration-app:int123 | grep "org.opencontainers.image.title"

            echo "=== Running the image ==="
            docker run --rm localhost:5000/intorg/integration-app:latest

            echo "=== Build-publish integration test PASSED ==="

      # Cleanup
      - run:
          name: Cleanup
          command: docker stop registry && docker rm registry

  # Test edge cases - empty additional_tags
  edge-case-empty-additional-tags-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      - run:
          name: Start local registry
          command: |
            docker run -d -p 5000:5000 --name registry registry:2
            sleep 3

      - run:
          name: Build test image
          command: |
            cat > Dockerfile \<<'EOF'
            FROM alpine:3.20
            CMD ["echo", "edge case test"]
            EOF
            docker build -t edge-test:single .

      # Test with only primary tag (empty additional tags scenario)
      - container-ops-orb/docker_tag:
          source_image: "edge-test:single"
          target_image: "localhost:5000/edge/edge-test"
          tags: "single-tag"

      - container-ops-orb/docker_push:
          image: "localhost:5000/edge/edge-test"
          tags: "single-tag"

      - run:
          name: Verify single tag push
          command: |
            docker rmi localhost:5000/edge/edge-test:single-tag || true
            docker pull localhost:5000/edge/edge-test:single-tag
            echo "Single tag edge case PASSED"

      - run:
          name: Cleanup
          command: docker stop registry && docker rm registry

  # Test special characters in tags (semver with pre-release)
  special-tags-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      - run:
          name: Start local registry
          command: |
            docker run -d -p 5000:5000 --name registry registry:2
            sleep 3

      - run:
          name: Build test image
          command: |
            cat > Dockerfile \<<'EOF'
            FROM alpine:3.20
            CMD ["echo", "special tags test"]
            EOF
            docker build -t special:base .

      # Test with semver including pre-release identifiers
      - container-ops-orb/docker_tag:
          source_image: "special:base"
          target_image: "localhost:5000/special/app"
          tags: "1.0.0-alpha.1 1.0.0-beta.2 1.0.0-rc.1 1.0.0"

      - container-ops-orb/docker_push:
          image: "localhost:5000/special/app"
          tags: "1.0.0-alpha.1 1.0.0-beta.2 1.0.0-rc.1 1.0.0"

      - run:
          name: Verify special tags
          command: |
            docker pull localhost:5000/special/app:1.0.0-alpha.1
            docker pull localhost:5000/special/app:1.0.0-beta.2
            docker pull localhost:5000/special/app:1.0.0-rc.1
            docker pull localhost:5000/special/app:1.0.0
            echo "Special tags test PASSED"

      - run:
          name: Cleanup
          command: docker stop registry && docker rm registry

  # Test publish job with additional_tags parameter
  publish-additional-tags-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      # Start local registry
      - run:
          name: Start local Docker registry
          command: |
            docker run -d -p 5000:5000 --name registry registry:2
            sleep 3

      # Build and prepare test image
      - run:
          name: Build test image
          command: |
            cat > Dockerfile \<<'EOF'
            FROM alpine:3.20
            LABEL org.opencontainers.image.title="Additional Tags Test"
            CMD ["echo", "test"]
            EOF
            docker build -t addtags-app:sha123 .

      # Archive the image
      - container-ops-orb/docker_archive:
          image: addtags-app
          tag: sha123
          persist_to_workspace: false

      # Remove original image
      - run:
          name: Remove original image
          command: docker rmi addtags-app:sha123

      # Test full flow with additional tags
      - container-ops-orb/docker_load:
          image: addtags-app
          archive_path: ~/images
      - container-ops-orb/docker_tag:
          source_image: "addtags-app:sha123"
          target_image: "localhost:5000/org/addtags-app"
          tags: "sha123 edge develop-sha123"
      - container-ops-orb/docker_push:
          image: "localhost:5000/org/addtags-app"
          tags: "sha123 edge develop-sha123"

      # Verify all tags
      - run:
          name: Verify all additional tags pushed
          command: |
            docker rmi localhost:5000/org/addtags-app:sha123 || true
            docker rmi localhost:5000/org/addtags-app:edge || true
            docker rmi localhost:5000/org/addtags-app:develop-sha123 || true
            docker pull localhost:5000/org/addtags-app:sha123
            docker pull localhost:5000/org/addtags-app:edge
            docker pull localhost:5000/org/addtags-app:develop-sha123
            echo "All additional tags verified!"

      # Cleanup
      - run:
          name: Cleanup
          command: docker stop registry && docker rm registry

  # Test the full build job
  job-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      # Create a test Dockerfile in a subdirectory
      - run:
          name: Create test Dockerfile
          command: |
            mkdir -p containers/test
            cat > containers/test/Dockerfile \<<'EOF'
            ARG OCI_CREATED
            ARG OCI_REVISION
            ARG OCI_VERSION

            FROM alpine:3.20

            LABEL org.opencontainers.image.title="Build Job Test"
            LABEL org.opencontainers.image.description="Test image for build job validation"
            LABEL org.opencontainers.image.created="${OCI_CREATED}"
            LABEL org.opencontainers.image.revision="${OCI_REVISION}"
            LABEL org.opencontainers.image.version="${OCI_VERSION}"

            CMD ["echo", "Build job test successful"]
            EOF

  # Integration test using the build job directly
  build-job-integration-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      - run:
          name: Create test Dockerfile
          command: |
            cat > Dockerfile \<<'EOF'
            ARG OCI_CREATED
            ARG OCI_REVISION
            ARG OCI_VERSION

            FROM alpine:3.20

            LABEL org.opencontainers.image.title="Integration Test"
            LABEL org.opencontainers.image.created="${OCI_CREATED}"
            LABEL org.opencontainers.image.revision="${OCI_REVISION}"
            LABEL org.opencontainers.image.version="${OCI_VERSION}"

            CMD ["echo", "Integration test passed"]
            EOF

  # Test scan job - scan from local image (loaded from archive)
  scan-local-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      # Build and archive a test image
      - run:
          name: Create test Dockerfile
          command: |
            cat > Dockerfile \<<'EOF'
            FROM alpine:3.20
            LABEL org.opencontainers.image.title="Scan Test Image"
            RUN apk add --no-cache curl
            CMD ["echo", "Scan test image"]
            EOF
      - container-ops-orb/docker_build:
          image: scan-test-app
          tags: "scan123"
      - container-ops-orb/docker_archive:
          image: scan-test-app
          tag: scan123
          persist_to_workspace: false

      # Remove image to ensure we load from archive
      - run:
          name: Remove image to test load
          command: docker rmi scan-test-app:scan123

      # Load and scan the image
      - container-ops-orb/docker_load:
          image: scan-test-app
          archive_path: ~/images

      # Install grype and scan
      - grype/install:
          version: "0.87.0"
          caching: true
      - grype/log_version
      - grype/update_database:
          caching: true

      # Prepare scan configuration
      - run:
          name: Prepare Scan Config
          environment:
            PARAM_IMAGE: scan-test-app
            PARAM_TAG: scan123
            PARAM_SCAN_SOURCE: local
            PARAM_ARCHIVE_PATH: ~/images
            PARAM_REGISTRY: ""
            PARAM_REGISTRY_NAMESPACE: ""
            PARAM_OUTPUT_DIR: scan-results
            PARAM_OUTPUT_FORMAT: sarif
          command: |
            mkdir -p scan-results
            source src/scripts/grype/prepare_scan.sh

      # Run the scan
      - grype/scan_image:
          image: scan-test-app:scan123
          output_file: scan-results/scan-test-app__scan123.grype.sarif
          output_format: sarif

      # Verify scan output was created
      - run:
          name: Verify scan results
          command: |
            echo "Checking for scan results..."
            ls -la scan-results/
            if [ -f scan-results/scan-test-app__scan123.grype.sarif ]; then
              echo "Scan results found!"
              head -50 scan-results/scan-test-app__scan123.grype.sarif
            else
              echo "ERROR: Scan results not found"
              exit 1
            fi

  # Test scan job - scan from archive directly
  scan-archive-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      # Build and archive a test image
      - run:
          name: Create test Dockerfile
          command: |
            cat > Dockerfile \<<'EOF'
            FROM alpine:3.20
            CMD ["echo", "Archive scan test"]
            EOF
      - container-ops-orb/docker_build:
          image: archive-scan-app
          tags: "archscan"
      - container-ops-orb/docker_archive:
          image: archive-scan-app
          tag: archscan
          persist_to_workspace: false

      # Install grype
      - grype/install:
          version: "0.87.0"
          caching: true
      - grype/update_database:
          caching: true

      # Scan directly from archive using docker-archive: scheme
      - run:
          name: Scan from archive directly
          command: |
            mkdir -p scan-results
            grype "docker-archive:$HOME/images/archive-scan-app-img.tar" -o json > scan-results/archive-scan.json

      # Verify results
      - run:
          name: Verify archive scan results
          command: |
            if [ -f scan-results/archive-scan.json ]; then
              echo "Archive scan results found!"
              echo "Vulnerability count:"
              grep -c '"vulnerability"' scan-results/archive-scan.json || echo "0 vulnerabilities found"
            else
              echo "ERROR: Archive scan results not found"
              exit 1
            fi

  # Test scan job with different output formats
  scan-formats-test:
    machine:
      image: ubuntu-2404:current
    resource_class: medium
    steps:
      - checkout
      # Build test image
      - run:
          name: Create test Dockerfile
          command: |
            cat > Dockerfile \<<'EOF'
            FROM alpine:3.20
            CMD ["echo", "Format test"]
            EOF
            docker build -t format-test:v1 .

      # Install grype
      - grype/install:
          version: "0.87.0"
          caching: true
      - grype/update_database:
          caching: true

      # Test multiple output formats
      - run:
          name: Test SARIF format
          command: |
            mkdir -p scan-results
            grype format-test:v1 -o sarif > scan-results/test.sarif
            echo "SARIF output created"
            head -20 scan-results/test.sarif

      - run:
          name: Test JSON format
          command: |
            grype format-test:v1 -o json > scan-results/test.json
            echo "JSON output created"
            head -20 scan-results/test.json

      - run:
          name: Test table format
          command: |
            grype format-test:v1 -o table > scan-results/test.txt
            echo "Table output created"
            cat scan-results/test.txt

      - run:
          name: Test CycloneDX JSON format
          command: |
            grype format-test:v1 -o cyclonedx-json > scan-results/test.cdx.json
            echo "CycloneDX JSON output created"
            head -20 scan-results/test.cdx.json

      - run:
          name: Verify all formats created
          command: |
            echo "All scan result files:"
            ls -la scan-results/
            echo "All formats test PASSED!"

workflows:
  test-deploy:
    jobs:
      # Test individual docker commands (including tag)
      - command-test:
          filters: *filters

      # Test docker_tag and docker_push commands with local registry
      - tag-push-command-test:
          filters: *filters

      # Test publish job flow with local registry
      - publish-job-local-registry-test:
          filters: *filters

      # Test tagger orb integration
      - tagger-integration-test:
          filters: *filters

      # Test publish with additional tags
      - publish-additional-tags-test:
          filters: *filters

      # Full build-to-publish integration test
      - build-publish-integration-test:
          filters: *filters

      # Edge case tests
      - edge-case-empty-additional-tags-test:
          filters: *filters

      # Special tags test (semver with pre-release)
      - special-tags-test:
          filters: *filters

      # Scan job tests
      - scan-local-test:
          filters: *filters

      - scan-archive-test:
          filters: *filters

      - scan-formats-test:
          filters: *filters

      # Test the build job directly with minimal config
      - container-ops-orb/build:
          name: build-job-simple-test
          image: orb-test-simple
          archive: true
          persist_to_workspace: false
          inspect: true
          pre_steps:
            - run:
                name: Create test Dockerfile
                command: |
                  cat > Dockerfile \<<'EOF'
                  ARG OCI_CREATED
                  ARG OCI_REVISION
                  ARG OCI_VERSION

                  FROM alpine:3.20

                  LABEL org.opencontainers.image.title="Simple Build Test"
                  LABEL org.opencontainers.image.created="${OCI_CREATED}"
                  LABEL org.opencontainers.image.revision="${OCI_REVISION}"
                  LABEL org.opencontainers.image.version="${OCI_VERSION}"

                  CMD ["echo", "Simple build test passed"]
                  EOF
          filters: *filters

      # Test with multi-stage Dockerfile
      - container-ops-orb/build:
          name: build-job-multistage-test
          image: orb-test-multistage
          target: prod
          tags: "latest ${CIRCLE_SHA1}"
          archive: true
          persist_to_workspace: false
          pre_steps:
            - run:
                name: Create multi-stage Dockerfile
                command: |
                  cat > Dockerfile \<<'EOF'
                  ARG OCI_CREATED
                  ARG OCI_REVISION
                  ARG OCI_VERSION

                  # Builder stage
                  FROM alpine:3.20 AS builder
                  RUN echo "Building..." > /build-output.txt

                  # Production stage
                  FROM alpine:3.20 AS prod
                  COPY --from=builder /build-output.txt /app/
                  LABEL org.opencontainers.image.title="Multi-stage Test"
                  LABEL org.opencontainers.image.created="${OCI_CREATED}"
                  LABEL org.opencontainers.image.revision="${OCI_REVISION}"
                  LABEL org.opencontainers.image.version="${OCI_VERSION}"
                  CMD ["cat", "/app/build-output.txt"]
                  EOF
          filters: *filters

      # Test with custom dockerfile path
      - container-ops-orb/build:
          name: build-job-custom-path-test
          image: orb-test-custom-path
          dockerfile: containers/app/Dockerfile
          docker_context: .
          archive: false
          inspect: true
          pre_steps:
            - run:
                name: Create Dockerfile in custom location
                command: |
                  mkdir -p containers/app
                  cat > containers/app/Dockerfile \<<'EOF'
                  FROM alpine:3.20
                  LABEL org.opencontainers.image.title="Custom Path Test"
                  CMD ["echo", "Custom path test passed"]
                  EOF
          filters: *filters

      # The orb must be re-packed for publishing, and saved to the workspace.
      - orb-tools/pack:
          filters: *release-filters

      - orb-tools/publish:
          orb_name: juburr/container-ops-orb
          vcs_type: << pipeline.project.type >>
          pub_type: production
          # Ensure this job requires all test jobs and the pack job.
          requires:
            - orb-tools/pack
            - command-test
            - tag-push-command-test
            - publish-job-local-registry-test
            - tagger-integration-test
            - publish-additional-tags-test
            - build-publish-integration-test
            - edge-case-empty-additional-tags-test
            - special-tags-test
            - scan-local-test
            - scan-archive-test
            - scan-formats-test
            - build-job-simple-test
            - build-job-multistage-test
            - build-job-custom-path-test
          context: orb-publishing
          filters: *release-filters
